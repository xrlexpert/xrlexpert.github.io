<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Solidity学习</title>
    <link href="/2023/04/08/Solidity/"/>
    <url>/2023/04/08/Solidity/</url>
    
    <content type="html"><![CDATA[<h1 id="Solidity学习"><a href="#Solidity学习" class="headerlink" title="Solidity学习"></a>Solidity学习</h1><p>由于大一立项的要求简洁的记录一下方便复习</p><span id="more"></span><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul><li>数值类型：调用时按值传递<ul><li>uint 无符号正整数(uint256的别名)</li><li>int  有符号整数(int256的别名)</li><li>int8 - int256(8到256位)</li><li>uint8 - uint256 (8到256位)</li><li>address 调用合约地址<ul><li><code>address</code>：保存一个20字节的值（以太坊地址的大小）。</li><li><code>address payable</code> ：可支付地址，与 <code>address</code> 相同，不过有成员函数 <code>transfer</code> 和 <code>send</code><ul><li>ap.transfer(10) 表示合约向ap转账10wei</li></ul></li></ul></li><li>bool 布尔类型</li></ul></li><li>引用类型：调用时按地址传递<ul><li>数组</li><li>结构体</li><li>函数</li><li>映射</li></ul></li></ul><h2 id="合约"><a href="#合约" class="headerlink" title="合约"></a>合约</h2><p>个人理解相当于C++中的类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT  /*注释用来注明代码的软件许可*/<br>pragma solidity ^0.8.4;  //声明solidity的版本<br>contract HelloWeb3&#123;<br>struct Student<br>&#123;<br>int data;<br>string id;<br>&#125;<br>    string public _string = &quot;Hello Web3!&quot;;  //合约的状态变量 相当于类的成员<br>    uint balance=0;<br>    uint []x=[1,2,3];<br>    function A()<br>    function B()<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>引用类型</strong>在函数中都需要一个额外的标注来表明数据存储的位置：</p><ul><li>storage：存储在链上。合约的状态变量都默认存储在链上。</li><li>memory：函数内的临时变量</li><li>calldata：相当于c++的const   函数参数的临时变量，且传进来不能被改变</li></ul><p>注意：如果在函数内创建一个storage变量指向合约的状态变量（必须是引用类型），那么改变该变量的同时会改变合约的状态变量<br>是指针还是复本：$storage&gt;memory&gt;calldata$ 当被赋值的类型 &#x3D;&#x3D;赋值的类型时，才是指针</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function()public pure <br>&#123;<br>uint []storage x_1=x;<br>x_1[1]=1;//此时balance也会变成1<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function &lt;function name&gt; (&lt;parameter types&gt;) &#123;internal|external|public|private&#125;   [pure|view|payable] [returns (&lt;return types&gt;)]<br><br>function returnName () external pure returns(uint index,bool _bool)<br>&#123;<br>return(12,true);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs solidity">mapping(uint=&gt;student)a; <br></code></pre></td></tr></table></figure><p>key只能为数值类型<br>value可以是任何类型·</p><h2 id="构造函数与修饰器"><a href="#构造函数与修饰器" class="headerlink" title="构造函数与修饰器"></a>构造函数与修饰器</h2><p>构造函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs solidity">constructor(参数)  //用来对状态变量进行初始化<br>&#123;<br>.....<br>&#125;<br><br></code></pre></td></tr></table></figure><p>修饰器（<code>modifier</code>）是<code>solidity</code>特有的语法，类似于面向对象编程中的<code>decorator</code>，声明函数拥有的特性<br>相当于执行函数前需要判断的条件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 定义modifier<br>modifier onlyOwner &#123;<br>   require(msg.sender == owner); // 检查调用者是否为owner地址<br>   _; // 如果是的话，继续运行函数主体；否则报错并revert交易<br>&#125;<br><br>//代有onlyOwner修饰符的函数只能被owner地址调用<br>function changeOwner(address _newOwner) external onlyOwner&#123;<br>   owner = _newOwner; // 只有owner地址运行这个函数，并改变owner<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p><strong>继承格式</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract A is B,C,D...<br>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>如果B，C，D….之间仍然有继承关系，需要从辈分由高到低顺序排序</li></ul><p><strong>函数继承</strong></p><ul><li>父类中的函数如果希望被子类重写需要加上<code>virtual</code>关键字</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract Yeye &#123;<br>    event Log(string msg);<br><br>    // 定义3个function: hip(), pop(), man()，Log值为Yeye。<br>    function hip() public virtual&#123;<br>        emit Log(&quot;Yeye&quot;);<br>    &#125;<br><br>    function pop() public virtual&#123;<br>        emit Log(&quot;Yeye&quot;);<br>    &#125;<br><br>    function yeye() public virtual &#123;<br>        emit Log(&quot;Yeye&quot;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>子类重写父类的函数再加上<code>override</code>关键字</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract Baba is Yeye&#123;<br>    // 继承两个function: hip()和pop()，输出改为Baba。<br>    function hip() public virtual override&#123;<br>        emit Log(&quot;Baba&quot;);<br>    &#125;<br><br>    function pop() public virtual override&#123;<br>        emit Log(&quot;Baba&quot;);<br>    &#125;<br><br>    function baba() public virtual&#123;<br>        emit Log(&quot;Baba&quot;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>构造函数的继承</strong></p><ul><li>需要标明父类继承中的参数格式</li><li>然后再写该子类构造器参数与父类构造器参数之间的关系</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract C is A &#123;<br>    constructor(uint _c) A(_c * _c) &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>调用父类的函数</strong></p><ul><li>直接调用：父类名.函数名( )</li><li><code>super</code>关键字调用：super.函数名( )  调用继承关系最亲近的那个父类的函数</li></ul><h2 id="抽象合约和接口"><a href="#抽象合约和接口" class="headerlink" title="抽象合约和接口"></a>抽象合约和接口</h2><p><strong>抽象合约</strong></p><p>如果一个智能合约里至少有一个未实现的函数，即某个函数缺少主体<code>&#123;&#125;</code>中的内容，则必须将该合约标为<code>abstract</code>，不然编译会报错；另外，未实现的函数需要加<code>virtual</code>，以便子合约重写。如果我们还没想好具体怎么实现某个函数，那么可以把合约标为<code>abstract</code>，之后让别人补写上。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs solidity">abstract contract InsertionSort&#123;<br>    function insertionSort(uint[] memory a) public pure virtual returns(uint[] memory);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>接口</strong></p><ol><li>不能包含状态变量</li><li>不能包含构造函数</li><li>不能继承除接口外的其他合约</li><li>所有函数都必须是external且不能有函数体</li><li>继承接口的合约必须实现接口定义的所有功能</li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">interface</span> <span class="hljs-title">base</span><br>&#123;<br><span class="hljs-function">function <span class="hljs-title">getFirstName</span>()<span class="hljs-keyword">public</span> pure <span class="hljs-title">retruns</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> memory</span>)</span>;<br>&#125;<br>contract B <span class="hljs-keyword">is</span> <span class="hljs-keyword">base</span><br>&#123;<br><span class="hljs-function">function <span class="hljs-title">getFirstName</span>()<span class="hljs-keyword">public</span> pure <span class="hljs-title">retruns</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> memory</span>)</span><br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;HAHA&quot;</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>大一立项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>solidity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Poj2227题解 水库体积</title>
    <link href="/2023/04/02/Poj2227/"/>
    <url>/2023/04/02/Poj2227/</url>
    
    <content type="html"><![CDATA[<h1 id="Poj2227题解水库体积"><a href="#Poj2227题解水库体积" class="headerlink" title="Poj2227题解水库体积"></a>Poj2227题解水库体积</h1><p><a href="http://poj.org/problem?id=2227">题目链接</a></p><p><strong>题目</strong>：已知有一个W×H面积大小的水库，里面由W×H个1×1大小的砖块构成，每个砖块的高度为 H.求该水库最多能储存多少单位的水？</p><span id="more"></span><h2 id="如何计算体积？"><a href="#如何计算体积？" class="headerlink" title="如何计算体积？"></a>如何计算体积？</h2><p><strong>短板效应</strong>：一个1×1的区域内最多存储多少水取决于它所在<strong>边界</strong>中<strong>最矮的那一块板子</strong>  <br><br>拿3×3的方格举例：只有最中间(坐标为(2,2) )的方格能储存水，且体积大小 $V&#x3D;1×1×(H_{边界中最矮}-H_{2，2})$</p><ul><li><strong>推论</strong>：一个砖块能存储的体积，只与离他最近周围四个砖块高度有关</li></ul><p>思路：考虑将一个一个单位的砖块相加即为最终体积<br>首先将水库最外围的每个砖块按高度由矮到高排序（优先队列 $ O(logn) $）<br><br>每次弹出当前最矮的砖块，搜索周围四个坐标。</p><ul><li>如果坐标的高度大于等于边界高度，则无法蓄水，该坐标成为新的边界加入队列</li><li>如果坐标的高度小于边界高度，则可以蓄水 $H_{边界} - H_{x,y}$, 将该坐标的高度改为边界的高度，成为新的边界加入队列</li></ul><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 100000</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span><br>&#123;<br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-type">int</span> y;<br>    <span class="hljs-type">int</span> h;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-type">const</span> Node x)<span class="hljs-type">const</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> h&gt;x.h;<br>    &#125;<br>&#125;;<br><span class="hljs-type">int</span> f[<span class="hljs-number">303</span>][<span class="hljs-number">303</span>];  <span class="hljs-comment">//记录每个坐标的高度</span><br><span class="hljs-type">int</span> w,h;<br><span class="hljs-type">int</span> d[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>]=&#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;&#125;;<br><span class="hljs-type">int</span> ans;<br>priority_queue&lt;Node&gt; q;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;w&gt;&gt;h;<br>    <span class="hljs-type">int</span> vis[<span class="hljs-number">303</span>][<span class="hljs-number">303</span>]=&#123;&#125;;<br>    <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=h;i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=w;j++)<br>        &#123;<br>            cin&gt;&gt;f[i][j];<br>            Node tmp;<br>            <span class="hljs-keyword">if</span>(i==<span class="hljs-number">1</span>||i==h||j==<span class="hljs-number">1</span>||j==w)<br>            &#123;<br>                Node tmp;<br>                tmp.x=i;<br>                tmp.y=j;<br>                tmp.h=f[i][j];<br>                q.<span class="hljs-built_in">push</span>(tmp);      <span class="hljs-comment">//队列中存储的是每次判断依赖的边界</span><br>                vis[i][j]=<span class="hljs-number">1</span>;       <span class="hljs-comment">//进入队列的就标记，后续计算面积时，不需要再加入了</span><br>            &#125;<br>            <br>            <br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        Node edge=q.<span class="hljs-built_in">top</span>();  <br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++) <span class="hljs-comment">//四个方向搜索</span><br>        &#123;<br>            <span class="hljs-type">int</span> nx=edge.x+d[i][<span class="hljs-number">0</span>];  <br>            <span class="hljs-type">int</span> ny=edge.y+d[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span>(vis[nx][ny]==<span class="hljs-number">0</span>&amp;&amp;nx&gt;=<span class="hljs-number">1</span>&amp;&amp;nx&lt;=h&amp;&amp;ny&gt;=<span class="hljs-number">1</span>&amp;&amp;ny&lt;=w)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(f[nx][ny]&gt;=edge.h)  <span class="hljs-comment">//如果当前砖块的高度大于等于边界，则无法蓄水，且会成为新的边界</span><br>                &#123;<br>                    vis[nx][ny]=<span class="hljs-number">1</span>;<br>                    Node tmp;<br>                    tmp.x=nx;<br>                    tmp.y=ny;<br>                    tmp.h=f[nx][ny];  <span class="hljs-comment">//将该位置的边界高度更改</span><br>                    q.<span class="hljs-built_in">push</span>(tmp);<br>                &#125;<br>                <span class="hljs-keyword">else</span>        <span class="hljs-comment">//如果当前砖块的高度小于边界，则可以蓄水，更新的边界高度不变</span><br>                &#123; <br>                    vis[nx][ny]=<span class="hljs-number">1</span>;<br>                    ans+=edge.h-f[nx][ny];<br>                    Node tmp;<br>                    tmp.x=nx;<br>                    tmp.y=ny;<br>                    tmp.h=edge.h;<br>                    q.<span class="hljs-built_in">push</span>(tmp);<br><br>                &#125;<br>            &#125;<br>        &#125;<br>        <br>    &#125;<br>    cout&lt;&lt;ans&lt;&lt;endl;<br>    <br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法学习</category>
      
      <category>BFS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Poj3278题解 农夫追牛</title>
    <link href="/2023/03/29/Poj3278/"/>
    <url>/2023/03/29/Poj3278/</url>
    
    <content type="html"><![CDATA[<h1 id="Poj-3278-农夫追牛"><a href="#Poj-3278-农夫追牛" class="headerlink" title="Poj 3278  农夫追牛"></a>Poj 3278  农夫追牛</h1><p><a href="http://poj.org/problem?id=3278">题目链接</a></p><p><em>已知农夫坐标为N，母牛坐标为K。每次农夫有三种移动方式，可移动到 X-1,X+1,2X 上，问最少需要移动多少次农夫可以移动到K。</em>        </p><span id="more"></span><h3 id="对于移动次数的最小值问题，通常采用BFS求解"><a href="#对于移动次数的最小值问题，通常采用BFS求解" class="headerlink" title="对于移动次数的最小值问题，通常采用BFS求解"></a>对于移动次数的最小值问题，通常采用BFS求解</h3><p>即遍历每一层，如果当前层数得到目标方案，即中止搜索。该层的层高最低，次数最小。</p><ul><li>每次移动有三种选择，对应同一层的三种情况。</li></ul><p>​首先，如果一个坐标已经走过了，那下一次一定不会再走这个坐标。因为N—&gt;X—&gt;K 比 N—&gt;X—&gt;Y—&gt;X—&gt;K更优，我们需要明确在步数最少的情况下，选定了一个坐标后以后的走法是唯一的，只跟当前坐标有关，而与之前怎么到该坐标方式无关。<strong>即在最优走法时，一个坐标点只会被经历一次。</strong>(有点像环，你好不容易走了很久，却又回到原点。那么之前的努力都白费了，一定不是最优解)<br>​并且使用BFS搜索的好处就在于，每个坐标在第一次被访问时，就是访问到该节点的最小次数，如果后续再访问到该点，可以剪枝排除（因为搜索情况和当前是一摸一样的）。因此使用 $ vis[ N ] $ 数组记录每个坐标的访问情况。</p><p><strong>然而该题目有一个很trick的地方在于:如果能通过2X超过K后再倒退得到最小值，那么其中一个最优的走法满足2X最多比t大一</strong>（最优的走法不唯一）  </p><div class="note note-success">            <p>证明</p>          </div><p>假设现在位置为X<br>分奇数偶数证明：<br></p><ol><li><p><em>偶数：</em><br>如果2X后比K大2n，按该方法会+1（变成2X 的那一步）+2n（倒退）&#x3D; <strong>1+2n</strong>；<br>则我可以先让X后退n步，再变成2X，即 $ 2（X-n） $ 。代价 <strong>n+1</strong> 比方法一更优（当且仅当n&#x3D;0时取等），且满足变成2x后，距离与K等于0&lt;&#x3D;1<br>此时距离为0</p></li><li><p><em>奇数：</em> <br>如果2X后比K大2n+1, 按该方法会+1（变成2X的那一步）+2n+1（倒退）&#x3D;<strong>2+2n</strong>；<br> 则我可以通过先后退n步，再加倍走，再后退一步，代价**+n+2**(当且仅当n&#x3D;0时取等)<br> <em>此时距离为1</em>  </p></li><li><p><strong>所以坐标范围限制在0到K+1</strong> ！！！大大减少了搜索范围，<del>否则就像我一样timeout了</del></p></li></ol><div class="note note-light">            <p>代码</p>          </div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,t;<br><span class="hljs-type">int</span> ans=<span class="hljs-number">1000000</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 200003</span><br><span class="hljs-type">int</span> a[N];<br><span class="hljs-type">int</span> vis[N];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span><br>&#123;<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-type">int</span> deep;<br>    <span class="hljs-built_in">node</span>(<span class="hljs-type">int</span> x1,<span class="hljs-type">int</span> d1)<br>    &#123;<br>        a=x1;<br>        deep=d1;<br>    &#125;<br>&#125;;<br>queue&lt;node&gt; q;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        node tmp=q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span>(tmp.a==t)<br>        &#123;<br>            cout&lt;&lt;tmp.deep;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">3</span>;i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(i==<span class="hljs-number">1</span>)<br>            &#123;<br>                <span class="hljs-type">int</span> x=tmp.a+<span class="hljs-number">1</span>;<br>                <span class="hljs-type">int</span> d=tmp.deep;<br>                <span class="hljs-keyword">if</span>(!vis[x]&amp;&amp;<span class="hljs-number">0</span>&lt;=x&amp;&amp;x&lt;=t+<span class="hljs-number">1</span>)<br>                &#123;<br>                    vis[x]=<span class="hljs-number">1</span>;<br>                    q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">node</span>(x,d+<span class="hljs-number">1</span>));<br>                &#125;<br>                <br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i==<span class="hljs-number">2</span>)<br>            &#123;<br>                <span class="hljs-type">int</span> x=<span class="hljs-number">2</span>*tmp.a;<br>                <span class="hljs-type">int</span> d=tmp.deep;<br>                <span class="hljs-keyword">if</span>(!vis[x]&amp;&amp;<span class="hljs-number">0</span>&lt;=x&amp;&amp;x&lt;=t+<span class="hljs-number">1</span>)<br>                &#123;<br>                    vis[x]=<span class="hljs-number">1</span>;<br>                    q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">node</span>(x,d+<span class="hljs-number">1</span>));<br><br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-type">int</span> x=tmp.a<span class="hljs-number">-1</span>;<br>                <span class="hljs-type">int</span> d=tmp.deep;<br>                <span class="hljs-keyword">if</span>(!vis[x]&amp;&amp;<span class="hljs-number">0</span>&lt;=x&amp;&amp;x&lt;=t+<span class="hljs-number">1</span>)<br>                &#123;<br>                    vis[x]=<span class="hljs-number">1</span>;<br>                    q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">node</span>(x,d+<span class="hljs-number">1</span>));<br><br>                &#125;<br>            &#125;<br>        &#125;<br><br>    &#125;<br>    <br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;t;<br>    <span class="hljs-keyword">if</span>(n==t)<br>    &#123;<br>        cout&lt;&lt;<span class="hljs-number">0</span>&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t&lt;n)<br>    &#123;<br>        cout&lt;&lt;(n-t)&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">node</span>(n,<span class="hljs-number">0</span>));<br>        vis[n]=<span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">bfs</span>();<br>    &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法学习</category>
      
      <category>BFS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
