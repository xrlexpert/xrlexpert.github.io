<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>大一总结</title>
    <link href="/2023/06/25/%E5%A4%A7%E4%B8%80%E6%80%BB%E7%BB%93/"/>
    <url>/2023/06/25/%E5%A4%A7%E4%B8%80%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="大一总结">大一总结</h1><h2 id="前言">前言</h2><p>不知不觉间在哈深已经度过一年了，嘿嘿嘿。这是在18年以来第一次尝试做一些和自己感兴趣的事情，非常开心。在此希望多年后的自己看到这些会觉得这四年没白过。## 目录</p><ul><li><a href="#大一上">大一上</a></li><li><a href="#大一下">大一下</a></li><li><a href="#寒假">寒假</a></li></ul><h2 id="大一上">大一上</h2><p>大一进校就被高中的几个好朋友拉进学校的vex机器人战队打工，这段经历是我没法忘却的，战队里的学长学姐都太优秀了，人也超级超级好。在此特别感谢冬阳，隆斌学长，带着我快速上手了c语言,git,markdown等知识，也初步了解了机器人软件开发的部分内容。最后在大一下快开学的时候由于想和朋友一起转入算法竞赛最终退出了（虽然自己真的很不舍），希望战队越来越好！</p><p>在这一期间也了解到了csdiy这个自学指南，上了深专一学期的课，除了ygq的高数，pwj的集合论，其余都相当于自学。果真应证了那句话：大学==自学。这一学期学分绩自认为也比较努力了，但排名仍旧很拉跨，保研线边缘，但相比于卷学分绩我更想知道自己喜欢计算机的哪个领域方向，所以继续做自己就好。</p><ul><li>集合论与图论94：由于疫情拖到放假后返校才考试，考试前两三周便开始看ppt和学长写的笔记+往年卷，最终算是考得还行</li><li>程序设计语言93：期末90都没上，可能自己部分的知识点还没掌握扎实，复习就看了ppt+做往年题</li><li>代数与几何91：个人觉得考试难度其实不大，但就是容易扣细节上的分，现在已经忘得差不多了。复习就看书+做题</li><li>微积分85：高数没有一次是0失误的，鉴于分值5分一道，稍微忽视一点细节就被扣一分，唉，果然我还是不适合考试。</li></ul><h2 id="大一下">大一下</h2><p>这个学期退出战队后有很多课余时间，上半学期先自学了一些算法并做洛谷，参加校内程序设计竞赛拿了三等奖（但和年级大佬的差距还不小，还不够努力啊），鉴于后半学期很忙，便没有再刷洛谷了，寒假准备全身心投入试试。</p><p>五一和家里人一起去了趟广州，不得不说广东的早茶是真的好吃！</p><p>自学了一下cs61b但介于项目代码量有点大+和学校内容近似+英语能力不行，最终鸽了，寒假有时间做做。</p><p>6月15号过生，和好朋友一起吃了顿饭，收到很多朋友的祝福，很开心。然而就在这一天后遇到了一些不可描述的事情影响自己心情，期末也没按照计划复习好，很是难受，“帮助别人前，避免自己落入深渊”。估计这学期的学分绩又要--，但没关系，下学期再冲！</p><ul><li>数据结构84：期末78，自己写了一个月的考研题没想到是这个结果。碍于手写代码+对试卷题量认识不清晰，没做完，最后30分大题草草结束，对于试卷本身的题目我就不想评价了。</li><li>近代史84：正常，第一次没经验，自己写了一大堆笔记最终效率贼低，还不如只听串讲。下次千万注意这种考试就死盯着<strong>串讲</strong>复习就行了，面向串讲考试，一周复习即可。</li></ul><h2 id="寒假">寒假</h2><p>目标：</p><ul><li>学习python+概率论，为数模做准备</li><li>算法竞赛训练，打打周赛</li><li>学习雅思，把英语补一补（其实主要考自学，重在坚持）</li><li>学习DDCA，预计耗时四周</li></ul>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大学生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Solidity学习</title>
    <link href="/2023/04/08/Solidity/"/>
    <url>/2023/04/08/Solidity/</url>
    
    <content type="html"><![CDATA[<h1 id="solidity学习">Solidity学习</h1><p>由于大一立项的要求简洁的记录一下方便复习</p><span id="more"></span><h2 id="数据类型">数据类型</h2><ul><li>数值类型：调用时按值传递<ul><li>uint 无符号正整数(uint256的别名)</li><li>int 有符号整数(int256的别名)</li><li>int8 - int256(8到256位)</li><li>uint8 - uint256 (8到256位)</li><li>address 调用合约地址<ul><li><code>address</code>：保存一个20字节的值（以太坊地址的大小）。</li><li><code>address payable</code> ：可支付地址，与 <code>address</code>相同，不过有成员函数 <code>transfer</code> 和 <code>send</code><ul><li>ap.transfer(10) 表示合约向ap转账10wei</li></ul></li></ul></li><li>bool 布尔类型</li></ul></li><li>引用类型：调用时按地址传递<ul><li>数组</li><li>结构体</li><li>函数</li><li>映射</li></ul></li></ul><h2 id="合约">合约</h2><p>个人理解相当于C++中的类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT  /*注释用来注明代码的软件许可*/<br>pragma solidity ^0.8.4;  //声明solidity的版本<br>contract HelloWeb3&#123;<br>struct Student<br>&#123;<br>int data;<br>string id;<br>&#125;<br>    string public _string = &quot;Hello Web3!&quot;;  //合约的状态变量 相当于类的成员<br>    uint balance=0;<br>    uint []x=[1,2,3];<br>    function A()<br>    function B()<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>引用类型</strong>在函数中都需要一个额外的标注来表明数据存储的位置：</p><ul><li>storage：存储在链上。合约的状态变量都默认存储在链上。</li><li>memory：函数内的临时变量</li><li>calldata：相当于c++的const函数参数的临时变量，且传进来不能被改变</li></ul><p>注意：如果在函数内创建一个storage变量指向合约的状态变量（必须是引用类型），那么改变该变量的同时会改变合约的状态变量是指针还是复本：<spanclass="math inline">\(storage&gt;memory&gt;calldata\)</span>当被赋值的类型 ==赋值的类型时，才是指针</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function()public pure <br>&#123;<br>uint []storage x_1=x;<br>x_1[1]=1;//此时balance也会变成1<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="函数">函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function &lt;function name&gt; (&lt;parameter types&gt;) &#123;internal|external|public|private&#125;   [pure|view|payable] [returns (&lt;return types&gt;)]<br><br>function returnName () external pure returns(uint index,bool _bool)<br>&#123;<br>return(12,true);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="映射">映射</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs solidity">mapping(uint=&gt;student)a; <br></code></pre></td></tr></table></figure><p>key只能为数值类型 value可以是任何类型·</p><h2 id="构造函数与修饰器">构造函数与修饰器</h2><p>构造函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs solidity">constructor(参数)  //用来对状态变量进行初始化<br>&#123;<br>.....<br>&#125;<br><br></code></pre></td></tr></table></figure><p>修饰器（<code>modifier</code>）是<code>solidity</code>特有的语法，类似于面向对象编程中的<code>decorator</code>，声明函数拥有的特性相当于执行函数前需要判断的条件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 定义modifier<br>modifier onlyOwner &#123;<br>   require(msg.sender == owner); // 检查调用者是否为owner地址<br>   _; // 如果是的话，继续运行函数主体；否则报错并revert交易<br>&#125;<br><br>//代有onlyOwner修饰符的函数只能被owner地址调用<br>function changeOwner(address _newOwner) external onlyOwner&#123;<br>   owner = _newOwner; // 只有owner地址运行这个函数，并改变owner<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="继承">继承</h2><p><strong>继承格式</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract A is B,C,D...<br>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>如果B，C，D....之间仍然有继承关系，需要从辈分由高到低顺序排序</li></ul><p><strong>函数继承</strong></p><ul><li>父类中的函数如果希望被子类重写需要加上<code>virtual</code>关键字</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract Yeye &#123;<br>    event Log(string msg);<br><br>    // 定义3个function: hip(), pop(), man()，Log值为Yeye。<br>    function hip() public virtual&#123;<br>        emit Log(&quot;Yeye&quot;);<br>    &#125;<br><br>    function pop() public virtual&#123;<br>        emit Log(&quot;Yeye&quot;);<br>    &#125;<br><br>    function yeye() public virtual &#123;<br>        emit Log(&quot;Yeye&quot;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>子类重写父类的函数再加上<code>override</code>关键字</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract Baba is Yeye&#123;<br>    // 继承两个function: hip()和pop()，输出改为Baba。<br>    function hip() public virtual override&#123;<br>        emit Log(&quot;Baba&quot;);<br>    &#125;<br><br>    function pop() public virtual override&#123;<br>        emit Log(&quot;Baba&quot;);<br>    &#125;<br><br>    function baba() public virtual&#123;<br>        emit Log(&quot;Baba&quot;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>构造函数的继承</strong></p><ul><li>需要标明父类继承中的参数格式</li><li>然后再写该子类构造器参数与父类构造器参数之间的关系</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract C is A &#123;<br>    constructor(uint _c) A(_c * _c) &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>调用父类的函数</strong></p><ul><li>直接调用：父类名.函数名( )</li><li><code>super</code>关键字调用：super.函数名( )调用继承关系最亲近的那个父类的函数</li></ul><h2 id="抽象合约和接口">抽象合约和接口</h2><p><strong>抽象合约</strong></p><p>如果一个智能合约里至少有一个未实现的函数，即某个函数缺少主体<code>&#123;&#125;</code>中的内容，则必须将该合约标为<code>abstract</code>，不然编译会报错；另外，未实现的函数需要加<code>virtual</code>，以便子合约重写。如果我们还没想好具体怎么实现某个函数，那么可以把合约标为<code>abstract</code>，之后让别人补写上。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs solidity">abstract contract InsertionSort&#123;<br>    function insertionSort(uint[] memory a) public pure virtual returns(uint[] memory);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>接口</strong></p><ol type="1"><li>不能包含状态变量</li><li>不能包含构造函数</li><li>不能继承除接口外的其他合约</li><li>所有函数都必须是external且不能有函数体</li><li>继承接口的合约必须实现接口定义的所有功能</li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">interface</span> <span class="hljs-title">base</span><br>&#123;<br><span class="hljs-function">function <span class="hljs-title">getFirstName</span>()<span class="hljs-keyword">public</span> pure <span class="hljs-title">retruns</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> memory</span>)</span>;<br>&#125;<br>contract B <span class="hljs-keyword">is</span> <span class="hljs-keyword">base</span><br>&#123;<br><span class="hljs-function">function <span class="hljs-title">getFirstName</span>()<span class="hljs-keyword">public</span> pure <span class="hljs-title">retruns</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> memory</span>)</span><br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;HAHA&quot;</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>大一立项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>solidity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Poj2227题解 水库体积</title>
    <link href="/2023/04/02/Poj2227/"/>
    <url>/2023/04/02/Poj2227/</url>
    
    <content type="html"><![CDATA[<h1 id="poj2227题解水库体积">Poj2227题解水库体积</h1><p><a href="http://poj.org/problem?id=2227">题目链接</a></p><p><strong>题目</strong>：已知有一个W×H面积大小的水库，里面由W×H个1×1大小的砖块构成，每个砖块的高度为H.求该水库最多能储存多少单位的水？</p><span id="more"></span><h2 id="如何计算体积">如何计算体积？</h2><p><strong>短板效应</strong>：一个1×1的区域内最多存储多少水取决于它所在<strong>边界</strong>中<strong>最矮的那一块板子</strong><br> 拿3×3的方格举例：只有最中间(坐标为(2,2) )的方格能储存水，且体积大小$ V=1×1×(H_{边界中最矮} - H_{2，2}) $</p><ul><li><strong>推论</strong>：一个砖块能存储的体积，只与离他最近周围四个砖块高度有关</li></ul><p>思路：考虑将一个一个单位的砖块相加即为最终体积首先将水库最外围的每个砖块按高度由矮到高排序（优先队列 $ O(logn) $）<br>每次弹出当前最矮的砖块，搜索周围四个坐标。</p><ul><li>如果坐标的高度大于等于边界高度，则无法蓄水，该坐标成为新的边界加入队列</li><li>如果坐标的高度小于边界高度，则可以蓄水 $ H_{边界} - H_{x,y} $,将该坐标的高度改为边界的高度，成为新的边界加入队列</li></ul><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 100000</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span><br>&#123;<br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-type">int</span> y;<br>    <span class="hljs-type">int</span> h;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-type">const</span> Node x)<span class="hljs-type">const</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> h&gt;x.h;<br>    &#125;<br>&#125;;<br><span class="hljs-type">int</span> f[<span class="hljs-number">303</span>][<span class="hljs-number">303</span>];  <span class="hljs-comment">//记录每个坐标的高度</span><br><span class="hljs-type">int</span> w,h;<br><span class="hljs-type">int</span> d[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>]=&#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;&#125;;<br><span class="hljs-type">int</span> ans;<br>priority_queue&lt;Node&gt; q;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;w&gt;&gt;h;<br>    <span class="hljs-type">int</span> vis[<span class="hljs-number">303</span>][<span class="hljs-number">303</span>]=&#123;&#125;;<br>    <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=h;i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=w;j++)<br>        &#123;<br>            cin&gt;&gt;f[i][j];<br>            Node tmp;<br>            <span class="hljs-keyword">if</span>(i==<span class="hljs-number">1</span>||i==h||j==<span class="hljs-number">1</span>||j==w)<br>            &#123;<br>                Node tmp;<br>                tmp.x=i;<br>                tmp.y=j;<br>                tmp.h=f[i][j];<br>                q.<span class="hljs-built_in">push</span>(tmp);      <span class="hljs-comment">//队列中存储的是每次判断依赖的边界</span><br>                vis[i][j]=<span class="hljs-number">1</span>;       <span class="hljs-comment">//进入队列的就标记，后续计算面积时，不需要再加入了</span><br>            &#125;<br>            <br>            <br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        Node edge=q.<span class="hljs-built_in">top</span>();  <br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++) <span class="hljs-comment">//四个方向搜索</span><br>        &#123;<br>            <span class="hljs-type">int</span> nx=edge.x+d[i][<span class="hljs-number">0</span>];  <br>            <span class="hljs-type">int</span> ny=edge.y+d[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span>(vis[nx][ny]==<span class="hljs-number">0</span>&amp;&amp;nx&gt;=<span class="hljs-number">1</span>&amp;&amp;nx&lt;=h&amp;&amp;ny&gt;=<span class="hljs-number">1</span>&amp;&amp;ny&lt;=w)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(f[nx][ny]&gt;=edge.h)  <span class="hljs-comment">//如果当前砖块的高度大于等于边界，则无法蓄水，且会成为新的边界</span><br>                &#123;<br>                    vis[nx][ny]=<span class="hljs-number">1</span>;<br>                    Node tmp;<br>                    tmp.x=nx;<br>                    tmp.y=ny;<br>                    tmp.h=f[nx][ny];  <span class="hljs-comment">//将该位置的边界高度更改</span><br>                    q.<span class="hljs-built_in">push</span>(tmp);<br>                &#125;<br>                <span class="hljs-keyword">else</span>        <span class="hljs-comment">//如果当前砖块的高度小于边界，则可以蓄水，更新的边界高度不变</span><br>                &#123; <br>                    vis[nx][ny]=<span class="hljs-number">1</span>;<br>                    ans+=edge.h-f[nx][ny];<br>                    Node tmp;<br>                    tmp.x=nx;<br>                    tmp.y=ny;<br>                    tmp.h=edge.h;<br>                    q.<span class="hljs-built_in">push</span>(tmp);<br><br>                &#125;<br>            &#125;<br>        &#125;<br>        <br>    &#125;<br>    cout&lt;&lt;ans&lt;&lt;endl;<br>    <br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法学习</category>
      
      <category>BFS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Poj3278题解 农夫追牛</title>
    <link href="/2023/03/29/Poj3278/"/>
    <url>/2023/03/29/Poj3278/</url>
    
    <content type="html"><![CDATA[<h1 id="poj-3278-农夫追牛">Poj 3278 农夫追牛</h1><p><a href="http://poj.org/problem?id=3278">题目链接</a></p><p><em>已知农夫坐标为N，母牛坐标为K。每次农夫有三种移动方式，可移动到X-1,X+1,2X 上，问最少需要移动多少次农夫可以移动到K。</em></p><span id="more"></span><h3id="对于移动次数的最小值问题通常采用bfs求解">对于移动次数的最小值问题，通常采用BFS求解</h3><p>即遍历每一层，如果当前层数得到目标方案，即中止搜索。该层的层高最低，次数最小。* 每次移动有三种选择，对应同一层的三种情况。</p><p>​首先，如果一个坐标已经走过了，那下一次一定不会再走这个坐标。因为N—&gt;X—&gt;K比N—&gt;X—&gt;Y—&gt;X—&gt;K更优，我们需要明确在步数最少的情况下，选定了一个坐标后以后的走法是唯一的，只跟当前坐标有关，而与之前怎么到该坐标方式无关。<strong>即在最优走法时，一个坐标点只会被经历一次。</strong>(有点像环，你好不容易走了很久，却又回到原点。那么之前的努力都白费了，一定不是最优解)​并且使用BFS搜索的好处就在于，每个坐标在第一次被访问时，就是访问到该节点的最小次数，如果后续再访问到该点，可以剪枝排除（因为搜索情况和当前是一摸一样的）。因此使用$ vis[ N ] $ 数组记录每个坐标的访问情况。</p><p><strong>然而该题目有一个很trick的地方在于:如果能通过2X超过K后再倒退得到最小值，那么其中一个最优的走法满足2X最多比t大一</strong>（最优的走法不唯一）</p><div class="note note-success">            <p>证明</p>          </div><p>假设现在位置为X 分奇数偶数证明：<br></p><ol type="1"><li><p><em>偶数：</em><br>如果2X后比K大2n，按该方法会+1（变成2X的那一步）+2n（倒退）= <strong>1+2n</strong>；则我可以先让X后退n步，再变成2X，即 $ 2（X-n） $ 。代价<strong>n+1</strong> 比方法一更优（当且仅当n=0时取等），且满足变成2x后，距离与K等于0&lt;=1<br>此时距离为0</p></li><li><p><em>奇数：</em> <br>如果2X后比K大2n+1,按该方法会+1（变成2X的那一步）+2n+1（倒退）=<strong>2+2n</strong>；则我可以通过先后退n步，再加倍走，再后退一步，代价<strong>+n+2</strong>(当且仅当n=0时取等)<em>此时距离为1</em><br /></p></li><li><p><strong>所以坐标范围限制在0到K+1</strong>！！！大大减少了搜索范围，<del>否则就像我一样timeout了</del></p></li></ol><div class="note note-light">            <p>代码</p>          </div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,t;<br><span class="hljs-type">int</span> ans=<span class="hljs-number">1000000</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 200003</span><br><span class="hljs-type">int</span> a[N];<br><span class="hljs-type">int</span> vis[N];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span><br>&#123;<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-type">int</span> deep;<br>    <span class="hljs-built_in">node</span>(<span class="hljs-type">int</span> x1,<span class="hljs-type">int</span> d1)<br>    &#123;<br>        a=x1;<br>        deep=d1;<br>    &#125;<br>&#125;;<br>queue&lt;node&gt; q;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        node tmp=q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span>(tmp.a==t)<br>        &#123;<br>            cout&lt;&lt;tmp.deep;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">3</span>;i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(i==<span class="hljs-number">1</span>)<br>            &#123;<br>                <span class="hljs-type">int</span> x=tmp.a+<span class="hljs-number">1</span>;<br>                <span class="hljs-type">int</span> d=tmp.deep;<br>                <span class="hljs-keyword">if</span>(!vis[x]&amp;&amp;<span class="hljs-number">0</span>&lt;=x&amp;&amp;x&lt;=t+<span class="hljs-number">1</span>)<br>                &#123;<br>                    vis[x]=<span class="hljs-number">1</span>;<br>                    q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">node</span>(x,d+<span class="hljs-number">1</span>));<br>                &#125;<br>                <br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i==<span class="hljs-number">2</span>)<br>            &#123;<br>                <span class="hljs-type">int</span> x=<span class="hljs-number">2</span>*tmp.a;<br>                <span class="hljs-type">int</span> d=tmp.deep;<br>                <span class="hljs-keyword">if</span>(!vis[x]&amp;&amp;<span class="hljs-number">0</span>&lt;=x&amp;&amp;x&lt;=t+<span class="hljs-number">1</span>)<br>                &#123;<br>                    vis[x]=<span class="hljs-number">1</span>;<br>                    q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">node</span>(x,d+<span class="hljs-number">1</span>));<br><br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-type">int</span> x=tmp.a<span class="hljs-number">-1</span>;<br>                <span class="hljs-type">int</span> d=tmp.deep;<br>                <span class="hljs-keyword">if</span>(!vis[x]&amp;&amp;<span class="hljs-number">0</span>&lt;=x&amp;&amp;x&lt;=t+<span class="hljs-number">1</span>)<br>                &#123;<br>                    vis[x]=<span class="hljs-number">1</span>;<br>                    q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">node</span>(x,d+<span class="hljs-number">1</span>));<br><br>                &#125;<br>            &#125;<br>        &#125;<br><br>    &#125;<br>    <br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;t;<br>    <span class="hljs-keyword">if</span>(n==t)<br>    &#123;<br>        cout&lt;&lt;<span class="hljs-number">0</span>&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t&lt;n)<br>    &#123;<br>        cout&lt;&lt;(n-t)&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">node</span>(n,<span class="hljs-number">0</span>));<br>        vis[n]=<span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">bfs</span>();<br>    &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法学习</category>
      
      <category>BFS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
